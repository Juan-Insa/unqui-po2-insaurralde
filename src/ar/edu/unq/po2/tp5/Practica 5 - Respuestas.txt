1. ¿Qué ventajas, en cuanto a polimorfismo, brindan las interfaces en java?

Las ventajas que brindan las interfaces en cuanto a polimorfismo es que establecen un protocolo a cumplir por las clases que la
la implementan. De esta forma, se asegura que todas las clases que implementan una interface determinada pueden responder los
mensajes establecidos en su protocolo. 
Además, las interfaces definen nuevos tipos. Clases que pertenecen a distintas jerarquías, con diferentes estados y comportamientos,
pueden tener un mismo tipo si comparten una misma interface.
Otra de las ventaja es que las interfaces permiten la herencia múltiple. Una clase puede implementar varias interfaces, contrario a
la herencia simple de clases.

2.¿Por qué no siempre puedo utilizar clases abstractas para agrupar clases polimórficas?

No siempre se pueden utilizar clases abstractas para agrupar clases polimórficas porque las clases pueden pertenecer a distintas jerarquías,
o sea, no compartir una superclase. La agrupación, en este caso, no es posible debido a que la herencia de clases es simple, esto quiere decir
que una clase no puede heredar de más de una superclase.


3.¿Qué ventajas tienen las clases abstractas sobre las interfaces?

Unas de las ventajas que tienen las clases abstractas sobre las interfaces es la posibilidad de implementar sus métodos para la
reutilización de código, definir modificadores de acceso (públicos, privados, estáticos y protegidos) y definir variables que no
sean por defecto o finales.
Las interfaces no implementan sus métodos, son implícitamente abstractos y de acceso público, sólo los definen para establecer un
protocolo.

4. ¿Se puede instranciar una interface?

Las interfaces no pueden ser instanciadas, sólo pueden ser implementadas por clases o extendidas por otras interfases.

5. ¿Por qué no es recomendable incrementar o modificar las firams definidas en un interface?

No es recomendable incrementar o modificar firmas ya definidas en una interface porque todas las clases que la implementen van a romper
dado que no estarían cumpliendo con el nuevo protocolo. Una practica recomendada sería crear otra interface que extienda la interface
a modificar o utilizar métodos por defecto (default methods).

6. ¿Por qué, en lenguajes como Smalltalk, no es necesaria la implementación de interfaces?

No es necesaria la implementación de interfaces porque se tratan de lenguajes que no son fuertemente tipados. Se asume de forma implícita
que un objeto sabe responder a un mensaje, por lo tanto no es necesario definir una interfaz de forma explícita.


-- INTERFACES, COLECCIONES Y OTRAS YERBAS --

¿Qué ocurriría si utiliza en lugar de XXX, YYY, WWW y ZZZ las clases e interfaces recientemente estudiadas?

En el caso de utilizar la interface Collection, no sería posible ejecutar los mensajes getfirstFrom y getSubCollection, dado que los métodos
get y subList no están definidos en su protocolo.

En el caso de utilizar la interface List, ArrayList y LinkedList, se podrían ejecutar todos los mensajes por tenerlos definidos en su protocolo.

La diferencia entre estos últimos es que ArrayList y LinkedList implementan de la interface List, esto quiere decir que si se pasa el tipo 
List por parámetro, este puede ambos tipos de lista. En cambio, si el tipo de parámetro es ArrayList o LinkedList, este deberá ser 
específicamente del tipo que fue definido por ser distintas clases, y por ende, de distintos tipos.

-- PERSONAS Y MASCOTAS --

4. ¿Fue necesario distinguir si el objeto era una Persona o una Mascota para poder imprimir su nombre? ¿Cómo se llama el mecanismo de 
abstracción que permite eso?

En el caso de Smalltalk no es necesario distinguir entre una Persona o una Mascota porque se trata de un lenguaje dinámico, no fuertemente
tipado. Mientra los objetos de la iteración sepan responder al mensaje pudiendo imprimirse en pantalla no importa del tipo que sean. Esto
es posible gracias al polimorfismo entre las clases.

5. 

¿Podría asegurar que tanto mascotas como personas respondan al mensaje getName() mediante herencia?¿Cómo?

se puede asegurar mediante herencia si ambas clases extienden de una superclase que tenga definido getName() como método abstracto. De esta
forma, las subclases se ven obligadas a implementarla.

¿Qué ocurre si Persona es subclase de otra clase que no puede ser modificada por ud.?

En este caso no se puede asegurar mediante herencia que las clases respondan al mensaje getName() debido a la herencia entre clases es simple
y Persona no podría tener otra superclase.

¿De qué otra manera puede asegurar el polimorfismo, teniendo en cuenta que está implementado en Java?

Otra manera de asegurar el polimorfismo entre estas clases en Java es que ambas implementen una interface que defina como protocolo el
mensaje getName(). Entonces, las clases van a estar obligadas a responder el mensaje.


